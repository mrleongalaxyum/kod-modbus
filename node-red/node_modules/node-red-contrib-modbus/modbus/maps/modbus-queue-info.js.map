{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusQueue","nodes","registerType","removeModbusQueueActionsFromNode","config","createNode","this","name","internalDebugLog","topic","unitid","parseInt","lowLowLevel","ModbusQueueInfo","highLevel","highHighLevel","lowLevel","updateOnAllUnitQueues","queueReadIntervalTime","updateOnAllQueueChanges","unitsWithQueue","node","Map","queueReadInterval","getNode","server","modbusClient","initUnitQueueStates","unit","registerForModbus","resetStates","unitWithQueue","get","lowLowLevelReached","lowLevelReached","highLevelReached","err","msg","logMsgError","checkLowLevelReached","bufferCommandListLength","now","state","modbusClientName","payload","checkHighLevelReached","Date","id","warn","send","highHighLevelReached","Error","getStatusSituationFillColor","fillColor","errorOnHighLevel","setNodeStatusByActivity","showStatusActivities","status","readFromQueue","updateStatusRrunning","bufferCommands","Promise","resolve","reject","bufferCommandList","length","checkQueueStates","readFromAllUnitQueues","registerModbusQueueActionsToNode","eventCallback","on","removeListener","setNodeStatusTo","queueEnabled","msgUnitId","resetQueue","unitId","errorProtocolMsg","allQueueData","date","lowlowLevel","sendEmptyMsgOnFail","queueOptions","verbose","infoText","msgQueueReset","shape","settings","fill","text","clearInterval","deregisterForModbus","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid) || 1\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n    this.showStatusActivities = config.showStatusActivities\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\n    this.updateOnAllUnitQueues = config.updateOnAllUnitQueues\n\n    this.internalDebugLog = internalDebugLog\n\n    const node = this\n    node.queueReadInterval = null\n    node.updateStatusRrunning = false\n    node.unitsWithQueue = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n\n    node.initUnitQueueStates = function () {\n      for (let unit = 0; unit < 256; unit += 1) {\n        node.unitsWithQueue.set(unit, {})\n        node.resetStates(unit)\n      }\n    }\n\n    node.resetStates = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      unitWithQueue.lowLowLevelReached = true\n      unitWithQueue.lowLevelReached = false\n      unitWithQueue.highLevelReached = false\n      unitWithQueue.highHighLevelReached = false\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.initUnitQueueStates()\n\n    node.checkLowLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLevelReached && bufferCommandListLength > node.lowLowLevel && bufferCommandListLength < node.lowLevel) {\n        unitWithQueue.lowLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'low level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          bufferCommandListLength\n        }\n        node.send(msg)\n      }\n    }\n\n    node.checkHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highLevelReached &&\n        bufferCommandListLength > node.lowLevel &&\n        bufferCommandListLength > node.highLevel) {\n        unitWithQueue.highLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          bufferCommandListLength\n        }\n\n        if (node.errorOnHighLevel) {\n          node.error(new Error('Queue High Level Reached'), msg)\n        } else {\n          node.warn(msg)\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highHighLevelReached &&\n        bufferCommandListLength > node.highLevel &&\n        bufferCommandListLength > node.highHighLevel) {\n        unitWithQueue.highHighLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel,\n          bufferCommandListLength\n        }\n        node.error(new Error('Queue High High Level Reached'), msg)\n        node.send(msg)\n      }\n    }\n\n    node.getStatusSituationFillColor = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      let fillColor = 'blue'\n\n      if (unitWithQueue.lowLevelReached) {\n        fillColor = 'green'\n      }\n\n      if (unitWithQueue.highLevelReached) {\n        if (node.errorOnHighLevel) {\n          fillColor = 'red'\n        } else {\n          fillColor = 'yellow'\n        }\n      }\n\n      if (unitWithQueue.highHighLevelReached) {\n        fillColor = 'red'\n      }\n\n      return fillColor\n    }\n\n    node.setNodeStatusByActivity = function (bufferCommandListLength, unit) {\n      if (node.showStatusActivities) {\n        node.status({\n          fill: node.getStatusSituationFillColor(node.unitid),\n          shape: 'ring',\n          text: (bufferCommandListLength) ? 'active unit ' + unit + ' queue items: ' + bufferCommandListLength : 'active (Unit-Id: ' + unit + ') empty'\n        })\n      }\n    }\n\n    node.readFromQueue = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n      const unit = ((node.unitid < 1 || node.unitid > 255)) ? 1 : node.unitid\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              const bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n              node.checkQueueStates(bufferCommandListLength, unit)\n              node.setNodeStatusByActivity(bufferCommandListLength, unit)\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      } else {\n        if (node.showStatusActivities) {\n          node.setNodeStatusByActivity(null, unit)\n        }\n      }\n    }\n\n    node.checkQueueStates = function (bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLowLevelReached && bufferCommandListLength < node.lowLowLevel) {\n        node.resetStates(unit)\n      }\n      node.checkLowLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighHighLevelReached(node, bufferCommandListLength, unit)\n    }\n\n    node.readFromAllUnitQueues = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              let bufferCommandListLength = 0\n              for (let unit = 0; unit < 256; unit += 1) {\n                bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n                if (!bufferCommandListLength) {\n                  continue\n                }\n                node.checkQueueStates(bufferCommandListLength, unit)\n              }\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      }\n    }\n\n    node.registerModbusQueueActionsToNode = function (eventCallback) {\n      if (node.updateOnAllQueueChanges) { // much more CPU-Load on many parallel requests to the client\n        modbusClient.on('mbqueue', eventCallback) // en-queue\n      }\n      modbusClient.on('mbactive', eventCallback) // de-queue\n      modbusClient.on('mbinit', eventCallback)\n      modbusClient.on('mbconnected', eventCallback)\n      modbusClient.on('mberror', eventCallback)\n      modbusClient.on('mbclosed', eventCallback)\n      node.queueReadInterval = setInterval(eventCallback, node.queueReadIntervalTime)\n    }\n\n    node.removeModbusQueueActionsFromNode = function (eventCallback) {\n      modbusClient.removeListener('mbqueue', eventCallback)\n      modbusClient.removeListener('mbactive', eventCallback)\n      modbusClient.removeListener('mbinit', eventCallback)\n      modbusClient.removeListener('mbconnected', eventCallback)\n      modbusClient.removeListener('mberror', eventCallback)\n      modbusClient.removeListener('mbclosed', eventCallback)\n    }\n\n    if (node.updateOnAllUnitQueues) {\n      node.registerModbusQueueActionsToNode(node.readFromAllUnitQueues)\n      mbBasics.setNodeStatusTo('active for all queues', node)\n    } else {\n      node.registerModbusQueueActionsToNode(node.readFromQueue)\n    }\n\n    node.on('input', function (msg) {\n      let msgUnitId = node.unitid\n      msg.payload = {}\n      msg.payload.queueEnabled = modbusClient.bufferCommands\n\n      if (node.updateOnAllUnitQueues) {\n        msg.payload.allQueueData = true\n        msg.payload.queues = modbusClient.bufferCommandList\n      } else {\n        try {\n          if (msg.payload.resetQueue) {\n            msgUnitId = parseInt(msg.payload.unitId) || node.unitid\n          } else {\n            msgUnitId = parseInt(msg.payload) || node.unitid\n          }\n        } catch (err) {\n          node.errorProtocolMsg(err, msg)\n          mbBasics.sendEmptyMsgOnFail(node, err, msg)\n          msgUnitId = node.unitid\n        }\n        msg.payload.allQueueData = false\n        msg.payload.unitid = msgUnitId\n        msg.payload.queue = modbusClient.bufferCommandList.get(msgUnitId)\n      }\n\n      msg.payload.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name || modbusClient.id,\n        lowlowLevel: node.lowlowLevel,\n        unitId: msgUnitId,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      const msgQueueReset = msg.payload.resetQueue || msg.resetQueue\n      if (msgQueueReset && modbusClient.bufferCommands) {\n        coreModbusQueue.initQueue(modbusClient)\n        if (RED.settings.verbose) {\n          const infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.initUnitQueueStates()\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: 'blue',\n            shape: 'ring',\n            text: 'active empty unit queue'\n          })\n        }\n        msg.payload.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      if (node.updateOnAllUnitQueues) {\n        node.removeModbusQueueActionsFromNode(node.readFromAllUnitQueues)\n      } else {\n        node.removeModbusQueueActionsFromNode(node.readFromQueue)\n      }\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}