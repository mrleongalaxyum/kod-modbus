{"version":3,"sources":["modbus-getter.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","internalDebugLog","nodes","registerType","config","createNode","this","mbIOCore","unitid","dataType","adr","ModbusGetter","quantity","showStatusActivities","msgThruput","showErrors","useIOFile","getNode","ioFile","connection","useIOForPayload","emptyMsgOnFail","logIOActivities","keepMsgProperties","verboseLogging","modbusClient","node","Map","bufferMessageList","server","registerForModbus","initModbusClientEvents","resp","onModbusCommandDone","msg","setNodeStatusTo","data","emit","err","logMsgError","onModbusCommandError","message","origMsg","getOriginalMessage","errorProtocolMsg","messageId","getObjectId","topic","buildNewMessageObject","id","payload","functionCodeModbusRead","value","fc","on","invalidPayloadIn","client","origMsgInput","Object","assign","newMsg","set","buildNewMessage","sendEmptyMsgOnFail","clear","deregisterForModbus","done","setNodeDefaultStatus"],"mappings":"aAYAA,OAAAC,QAAA,SAAAC,GAEAF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,mBAGMC,EAASD,QAAQ,sBAFvBA,EAAQA,QAAA,yBAIFE,EAAmBF,QAAQ,QAARA,CAAiB,wBAgH1CH,EAHGM,MAAAC,aAAA,gBA3GH,SAAuBC,GAJvBR,EAAMI,MAAMK,WAAWC,KAAAF,GACvBE,KAAMC,KAAQH,EAAGL,KAOfO,KAAKE,OAASJ,EAAOI,OAErBF,KAAKG,SAAWL,EAAOK,SANzBH,KAAAI,IAASC,EAAAA,IACPf,KAAIM,SAAMG,EAAWO,SAGrBN,KAAKE,qBAALJ,EAAAS,qBAEAP,KAAKG,WAAWL,EAAOK,WACvBH,KAAKI,WAAaA,EAAlBI,WACAR,KAAKM,WAAWR,KAGhBE,KAAKS,UAALX,EAAwBY,UACxBV,KAAKQ,OAAAA,EAAaV,MAAMa,QAACH,EAAzBI,QACAZ,KAAKa,gBAALf,EAAAgB,gBAEAd,KAAKU,gBAAkBZ,EAACY,gBAExBV,KAAKc,eAALhB,EAA6BiB,eAC7Bf,KAAKgB,kBAAkBlB,EAAOkB,kBAE9BhB,KAAKe,iBAAiBjB,EACtBE,KAAKiB,eAAL3B,EAAyBQ,SAAOmB,QAEhC,IAAKC,EAAAA,KAMCC,GAJNC,EAAMA,kBAAN,IAAAC,IACAD,EAAKE,gBAAoB,UAAzBF,GAGqB9B,EAAIM,MAAMe,QAAQb,EAAOyB,SACzCJ,IAEJA,EAAAK,kBAAAJ,GAED5B,EAASiC,uBAAuBL,EAAMD,GAAtC3B,EAAAA,oBAASiC,SAATC,EAAsCP,GAGhCC,EAAKb,sBADPf,EAACmC,gBAAsB,eAAgBC,GAIzCR,EAFE5B,KAAQS,EAAC4B,mBAAgBT,EAAgBA,EAAzCU,KAAAJ,EAAAE,IACDR,EAAAW,KAAA,yBAKHX,EAHEA,iBAAU,SAAVY,EAAAJ,GALFR,EAAAX,YAUIjB,EAASyC,YAAYb,EAAMY,EAAKJ,IAIpCR,EAHGc,qBAAA,SAAAF,EAAAJ,GAHHR,EAAAzB,iBAAAqC,EAAAG,SAQE,IAAMC,EAAU1C,EAAO2C,mBAAmBjB,EAAKE,kBAAmBM,GAFpER,EAAKc,iBAAAA,EAAuBE,GAC1BhB,EAAKzB,mBAAqBwC,EAA1BH,EAAAJ,GACApC,EAAM4C,eAAiBC,EAAAA,EAAuBL,EAACV,GAC/CF,EAAKkB,KAAAA,0BAMPlB,EAHEA,sBAAU,SAAVA,EAAAQ,GANF,IAAAW,EAAA7C,EAAA8C,cAWE,MAAO,CAFLC,MAACC,EAAAA,OAAAA,EAAwBC,GAC3BJ,UAAAA,EACAK,QAAO,CACLH,MAAOb,EAAIa,QAASrB,OADfQ,EAAAgB,QAELL,OAASnB,EAATmB,OACAK,GAAAA,EAASC,uBAAAzB,EAAAjB,UACP2C,QAAOlB,EAAIgB,IACX1C,SAAQkB,EAAKlB,SACb6C,UAAAA,KAQN3B,EAdE4B,GAAA,QAAA,SAAApB,GAFF,IAAApC,EAAAyD,iBAAArB,IAkBIT,EAAA+B,OAGF,CACEC,EAAAC,OAAAC,OAAA,GAAAzB,GACD,IAIC,IAAM0B,EAASlC,EAAKsB,sBAAsBtB,EAAM+B,GAFlD/B,EAAM+B,kBAAqBI,IAACF,EAAPd,UAAuB/C,EAAAgE,gBAAApC,EAAAH,kBAAAkC,EAAAG,IAI1CnC,EAAaY,KAAK,aAAcuB,EAAQlC,EAAKO,oBAAqBP,EAAKc,sBAFjEoB,EAAAA,sBACNlC,EAAKE,gBAAsBgC,EAAOf,mBAAoBiB,GAMtD,MAAOxB,GAHPZ,EAAIA,iBAAKb,EAAAA,GAKTf,EAJEA,mBAAyB2B,EAAAA,EAAYgC,OAQ3C/B,EAJI5B,GAAAA,QAASiE,SAAAA,GACVjE,EAAAqC,gBAAA,SAAAT,GArBHA,EAAAE,kBAAAoC,QAwBAtC,EAAAuC,oBAAiCvC,EAAAuB,GAAAiB,KAG/BzC,EAAAA,sBAHF3B,EAAAqE,qBAAAzC","file":"../modbus-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus Getter node.\n * @module NodeRedModbusGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:getter')\n\n  function ModbusGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.msgThruput = config.msgThruput\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusCommandDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusGetterNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusCommandError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusGetterNodeError')\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: msg.payload.value || msg.payload,\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusRead(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId\n        }\n      }\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg) // keep it origin\n      try {\n        const newMsg = node.buildNewMessageObject(node, origMsgInput)\n        node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, origMsgInput, newMsg))\n        modbusClient.emit('readModbus', newMsg, node.onModbusCommandDone, node.onModbusCommandError)\n\n        if (node.showStatusActivities) {\n          mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-getter', ModbusGetter)\n}\n"]}