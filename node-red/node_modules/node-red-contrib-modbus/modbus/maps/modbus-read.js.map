{"version":3,"sources":["modbus-read.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","internalDebugLog","nodes","registerType","config","createNode","this","mbIOCore","topic","dataType","ModbusRead","name","quantity","unitid","rate","startDelayTime","delayOnStart","parseInt","showStatusActivities","connection","useIOFile","ioFile","getNode","useIOForPayload","emptyMsgOnFail","verboseLogging","settings","verbose","timeoutOccurred","INPUT_TIMEOUT_MILLISECONDS","verboseWarn","node","warn","logMessage","adr","statusText","delayTimerReading","intervalTimerIdReading","setNodeStatusWithTimeTo","modbusClient","server","statusValue","statusOptions","setNodeStatusProperties","search","status","get_timeUnit_name","rateUnit","newStatusText","shape","fill","onModbusInit","onModbusConnect","resetAllReadingTimer","initializeReadingTimer","onModbusRegister","serialSendingAllowed","onModbusActive","onModbusQueue","onModbusError","failureMsg","reconnectOnTimeout","showErrors","onModbusClose","onModbusBroken","reconnectTimeout","onModbusReadDone","resp","msg","sendMessage","valueNames","removeNodeListenerFromModbusClient","id","internalDebug","values","response","filterValueNames","allValueNames","functionCodeModbusRead","logIOActivities","responseBuffer","input","sendingNodeId","origMsg","payload","err","logMsgError","onModbusReadError","message","errorProtocolMsg","client","from","fc","clearTimeout","resetDelayTimerToRead","resetIntervalToRead","clearInterval","setInterval","modbusPollingRead","calc_rateByUnit","setTimeout","startIntervalReading","removeListener","deregisterForModbus","done","on","auth","needsPermission","req","res","httpAdmin","post","params","sendStatus","_","error","toString"],"mappings":"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","file":"../modbus-read.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n Copyright 2013, 2016 IBM Corp. (node-red)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:read')\n\n  function ModbusRead (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity || 1\n\n    this.rate = config.rate\n    this.rateUnit = config.rateUnit\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    let timeoutOccurred = false\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    node.statusText = 'waiting'\n    node.delayTimerReading = false\n    node.intervalTimerIdReading = false\n    setNodeStatusWithTimeTo(node.statusText)\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Read -> ' + logMessage + ' address: ' + node.adr)\n      }\n    }\n\n    verboseWarn('open node ' + node.id)\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n\n    node.onModbusInit = function () {\n      setNodeStatusWithTimeTo('initialized')\n    }\n\n    node.onModbusConnect = function () {\n      setNodeStatusWithTimeTo('connected')\n      node.resetAllReadingTimer()\n      node.initializeReadingTimer()\n    }\n\n    node.onModbusRegister = function () {\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('registered')\n      }\n\n      if (modbusClient.serialSendingAllowed) {\n        node.resetAllReadingTimer()\n        node.initializeReadingTimer()\n        setNodeStatusWithTimeTo('connected')\n      }\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusWithTimeTo('active')\n    }\n\n    node.onModbusQueue = function () {\n      setNodeStatusWithTimeTo('queue')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      setNodeStatusWithTimeTo('failure')\n      if (modbusClient.reconnectOnTimeout) {\n        node.resetAllReadingTimer()\n      }\n\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      setNodeStatusWithTimeTo('closed')\n      node.resetAllReadingTimer()\n    }\n\n    node.onModbusBroken = function () {\n      setNodeStatusWithTimeTo('broken')\n      if (modbusClient.reconnectOnTimeout) {\n        setNodeStatusWithTimeTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.')\n        node.resetAllReadingTimer()\n      }\n    }\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('reading done')\n      }\n      sendMessage(resp.data, resp, msg)\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      node.errorProtocolMsg(err, msg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, msg)\n    }\n\n    node.modbusPollingRead = function () {\n      if (!modbusClient.client) {\n        setNodeStatusWithTimeTo('waiting')\n        return\n      }\n\n      const msg = {\n        topic: node.topic || 'polling',\n        from: node.name,\n        payload: {\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusRead(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: mbCore.getObjectId()\n        }\n      }\n\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('polling')\n      }\n\n      modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n    }\n\n    node.resetDelayTimerToRead = function (node) {\n      if (node.delayTimerReading) {\n        verboseWarn('resetDelayTimerToRead node ' + node.id)\n        clearTimeout(node.delayTimerReading)\n      }\n      node.delayTimerReading = null\n    }\n\n    node.resetIntervalToRead = function (node) {\n      if (node.intervalTimerIdReading) {\n        verboseWarn('resetIntervalToRead node ' + node.id)\n        clearInterval(node.intervalTimerIdReading)\n      }\n      node.intervalTimerIdReading = null\n    }\n\n    node.resetAllReadingTimer = function () {\n      node.resetDelayTimerToRead(node)\n      node.resetIntervalToRead(node)\n    }\n\n    node.resetAllReadingTimer()\n\n    node.startIntervalReading = function () {\n      if (!node.intervalTimerIdReading) {\n        verboseWarn('startIntervalReading node ' + node.id)\n        node.intervalTimerIdReading = setInterval(node.modbusPollingRead, mbBasics.calc_rateByUnit(node.rate, node.rateUnit))\n      }\n    }\n\n    node.initializeReadingTimer = function () {\n      node.resetAllReadingTimer()\n      if (node.delayOnStart) {\n        verboseWarn('initializeReadingTimer delay timer node ' + node.id)\n        node.delayTimerReading = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n      } else {\n        node.startIntervalReading()\n      }\n    }\n\n    node.removeNodeListenerFromModbusClient = function () {\n      modbusClient.removeListener('mbinit', node.onModbusInit)\n      modbusClient.removeListener('mbqueue', node.onModbusQueue)\n      modbusClient.removeListener('mbconnected', node.onModbusConnect)\n      modbusClient.removeListener('mbactive', node.onModbusActive)\n      modbusClient.removeListener('mberror', node.onModbusError)\n      modbusClient.removeListener('mbclosed', node.onModbusClose)\n      modbusClient.removeListener('mbbroken', node.onModbusBroken)\n      modbusClient.removeListener('mbregister', node.onModbusRegister)\n      modbusClient.removeListener('mbderegister', node.onModbusClose)\n    }\n\n    this.on('close', function (done) {\n      node.resetAllReadingTimer()\n      node.removeNodeListenerFromModbusClient()\n      setNodeStatusWithTimeTo('closed')\n      verboseWarn('close node ' + node.id)\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    function sendMessage (values, response, msg) {\n      const topic = msg.topic || node.topic\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n        if (node.logIOActivities) {\n          mbIOCore.internalDebug('node.adr:' + node.adr + ' node.quantity:' + node.quantity)\n        }\n\n        const allValueNames = mbIOCore.nameValuesFromIOFile(node, msg, values, response, node.adr)\n        const valueNames = mbIOCore.filterValueNames(node, allValueNames, mbCore.functionCodeModbusRead(node.dataType), node.adr, node.quantity)\n\n        const origMsg = {\n          topic,\n          responseBuffer: response,\n          input: msg,\n          sendingNodeId: node.id\n        }\n\n        if (node.useIOForPayload) {\n          origMsg.payload = valueNames\n          origMsg.values = values\n        } else {\n          origMsg.payload = values\n          origMsg.valueNames = valueNames\n        }\n\n        node.send([\n          origMsg,\n          {\n            topic,\n            payload: response,\n            values,\n            input: msg,\n            valueNames,\n            sendingNodeId: node.id\n          }])\n      } else {\n        node.send([\n          {\n            topic,\n            payload: values,\n            responseBuffer: response,\n            input: msg,\n            sendingNodeId: node.id\n          },\n          {\n            topic,\n            payload: response,\n            values,\n            input: msg,\n            sendingNodeId: node.id\n          }\n        ])\n      }\n    }\n\n    function setNodeStatusWithTimeTo (statusValue) {\n      if (statusValue === 'polling' && timeoutOccurred) {\n        return\n      }\n\n      const statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n      const statusText = node.statusText\n\n      if (statusValue.search('active') !== -1 || statusValue === 'polling') {\n        const newStatusText = statusOptions.status + getTimeInfo()\n        timeoutOccurred = false\n        if (newStatusText !== statusText) {\n          node.status({\n            fill: statusOptions.fill,\n            shape: statusOptions.shape,\n            text: newStatusText\n          })\n        }\n      } else {\n        const newStatusText = statusOptions.status\n        if (newStatusText !== statusText) {\n          node.status({\n            fill: statusOptions.fill,\n            shape: statusOptions.shape,\n            text: newStatusText\n          })\n        }\n      }\n    }\n\n    function getTimeInfo () {\n      return ' ( ' + node.rate + ' ' + mbBasics.get_timeUnit_name(node.rateUnit) + ' ) '\n    }\n\n    if (node.showStatusActivities) {\n      modbusClient.on('mbinit', node.onModbusInit)\n      modbusClient.on('mbqueue', node.onModbusQueue)\n    }\n\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbclosed', node.onModbusClose)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbregister', node.onModbusRegister)\n    modbusClient.on('mbderegister', node.onModbusClose)\n\n    modbusClient.registerForModbus(node)\n  }\n\n  RED.nodes.registerType('modbus-read', ModbusRead)\n\n  RED.httpAdmin.post('/modbus/read/inject/:id', RED.auth.needsPermission('modbus.inject.write'), function (req, res) {\n    const node = RED.nodes.getNode(req.params.id)\n\n    if (node) {\n      try {\n        node.modbusPollingRead()\n        res.sendStatus(200)\n      } catch (err) {\n        res.sendStatus(500)\n        node.error(RED._('modbusinject.failed', { error: err.toString() }))\n      }\n    } else {\n      res.sendStatus(404)\n    }\n  })\n}\n"]}