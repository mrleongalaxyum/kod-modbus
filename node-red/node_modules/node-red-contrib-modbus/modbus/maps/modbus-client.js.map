{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusClient","internalDebugLog","nodes","registerType","config","ModbusRTU","minCommandDelayMilliseconds","node","this","serialConnectionDelayTimeMS","undefined","reconnectTimeMS","logHintText","clienttype","queueLogEnabled","stateLogEnabled","failureLogEnabled","bufferCommands","tcpHost","tcpType","tcpPort","parseInt","serialDatabits","serialPort","serialBaudrate","serialStopbits","serialConnectionDelay","serialParity","serialAsciiResponseStartDelimiter","unit_id","commandDelay","clientTimeout","reconnectOnTimeout","parallelUnitIdsAllowed","serverInfo","logMessage","settings","verbose","updateServerinfo","verboseWarn","verboseLog","internalDebug","isFirstInitOfConnection","closingModbus","Map","client","bufferCommandList","sendingAllowed","messagesAllowedStates","unitSendingAllowed","stateMachine","stateService","createStateMachineService","actualServiceState","actualServiceStateBefore","reconnectTimeoutId","serialSendingAllowed","coreModbusQueue","queueSerialLockCommand","setDefaultUnitId","setUnitIdFromPayload","msg","unitId","getActualUnitId","checkUnitId","setID","Number","isNaN","queueLog","subscribe","state","value","matches","initQueue","setTimeout","reconnectTimeout","connectClient","error","queueSerialUnlockCommand","emit","checkQueuesAreEmpty","send","dequeueCommand","err","message","close","on","modbusErrorHandling","timeoutTimeMS","payload","Error","autoOpen","setTCPConnectionOptions","then","setTCPConnected","modbusTcpErrorHandling","port","connectTelnet","connectTcpRTUBuffered","connectTCP","serialPortOptions","baudRate","stopBits","parity","startOfSlaveFrameChar","toString","connectAsciiSerial","setSerialConnectionOptions","serialType","connectRTU","modbusSerialErrorHandling","connectRTUBuffered","e","modbusSerialDebug","JSON","stringify","networkErrors","includes","errno","showErrors","code","openSerialClient","_port","onModbusClose","messageAllowedStates","indexOf","pushToQueueByUnitId","readModbus","cb","cberr","info","get","queueUnitId","length","queueLength","writeModbus","activateSending","set","Promise","resolve","reject","setMaxListeners","invalidPayloadIn","setNewNodeSettings","done","nodeIdentifierName","name","id","removeAllListeners","isOpen","registeredNodeList","registerForModbus","clientUserNodeId","Object","keys","setStoppedState","closeConnectionWithoutRegisteredNodes","httpAdmin","auth","needsPermission","req","res","SerialPort","list","ports","json"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n    const serialAsciiResponseStartDelimiter = '0x3A'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n    this.failureLogEnabled = config.failureLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n    this.serialAsciiResponseStartDelimiter = config.serialAsciiResponseStartDelimiter || serialAsciiResponseStartDelimiter\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.updateServerinfo()\n        node.warn('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          node.stateService.send('SEND')\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      try {\n        if (node.client) {\n          try {\n            node.client.close(function () {\n              verboseLog('connection closed')\n            })\n            verboseLog('connection close sent')\n          } catch (err) {\n            verboseLog(err.message)\n          }\n        }\n        node.client = null\n        node.client = new ModbusRTU()\n\n        node.client.on('error', (err) => {\n          node.modbusErrorHandling(err)\n          mbBasics.setNodeStatusTo('error', node)\n        })\n\n        if (!node.clientTimeout) {\n          node.clientTimeout = timeoutTimeMS\n        }\n\n        if (!node.reconnectTimeout) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n\n        if (node.clienttype === 'tcp') {\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          try {\n            switch (node.tcpType) {\n              case 'C701':\n                verboseLog('C701 port UDP bridge')\n                node.client.connectC701(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .then(node.setTCPConnected)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'TELNET':\n                verboseLog('Telnet port')\n                node.client.connectTelnet(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'TCP-RTU-BUFFERED':\n                verboseLog('TCP RTU buffered port')\n                node.client.connectTcpRTUBuffered(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('TCP port')\n                node.client.connectTCP(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n            }\n          } catch (e) {\n            node.modbusTcpErrorHandling(e)\n            return false\n          }\n        } else {\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          if (!node.serialConnectionDelay) {\n            node.serialConnectionDelay = serialConnectionDelayTimeMS\n          }\n\n          if (!node.serialPort) {\n            node.error(new Error('wrong serial port'), { payload: node.serialPort })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          const serialPortOptions = {\n            baudRate: parseInt(node.serialBaudrate),\n            dataBits: parseInt(node.serialDatabits),\n            stopBits: parseInt(node.serialStopbits),\n            parity: node.serialParity,\n            autoOpen: false\n          }\n\n          try {\n            switch (node.serialType) {\n              case 'ASCII':\n                verboseLog('ASCII port serial')\n                // Make sure is parsed when string, otherwise just assign.\n                if (node.serialAsciiResponseStartDelimiter && typeof node.serialAsciiResponseStartDelimiter === 'string') {\n                  serialPortOptions.startOfSlaveFrameChar = parseInt(node.serialAsciiResponseStartDelimiter, 16)\n                } else {\n                  serialPortOptions.startOfSlaveFrameChar = node.serialAsciiResponseStartDelimiter\n                }\n                verboseLog('Using response delimiter: 0x' + serialPortOptions.startOfSlaveFrameChar.toString(16))\n\n                node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'RTU':\n                verboseLog('RTU port serial')\n                node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('RTU buffered port serial')\n                node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n            }\n          } catch (e) {\n            node.modbusSerialErrorHandling(e)\n            return false\n          }\n        }\n      } catch (err) {\n        node.modbusErrorHandling(err)\n        return false\n      }\n\n      return true\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      if ((err.errno && coreModbusClient.networkErrors.includes(err.errno)) ||\n      (err.code && coreModbusClient.networkErrors.includes(err.code))) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('SWITCH')\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n      node.removeAllListeners()\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n      } else {\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      res.json([err.message])\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}