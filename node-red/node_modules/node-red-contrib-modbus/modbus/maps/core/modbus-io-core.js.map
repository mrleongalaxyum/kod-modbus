{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioCore","ioFile","configData","forEach","mapping","push","buildInputAddressMapping","Number","addressOffset","logIOActivities","buildOutputAddressMapping","valueAddress","startsWith","allValueNamesFromIOFile","ioNode","insertValues","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStartIO","addressStart","coilStart","bits","bitAddress","name","substring","registerType","addressType","split","Math","floor","addressOffsetIO","Bit","dataType","error","register","registerAddress","index","item","prototype","hasOwnProperty","call","JSON","stringify","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","isRegisterSizeWrong","readInt8","readInt16BE","convertedValue","readIntBE","readFloatBE","readDoubleBE","readUInt32BE","readUIntBE","convertValuesByType","Object","readInt32BE","buffer","err","message","filterValueNames","fc","adr","quantity","functionType","startRegister","endRegister","filter","valueName","start","sizeDivisor","sixteenBitBufferLength","buildMessageWithIO","bufferMessageList","rawMsg","origMsg","modbusRequest","assign","payload","topic","lastUpdatedAt","parseInt","this","allValueNames","address","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { io: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\n  let valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (node.ioFile && node.ioFile.configData) {\n    node.ioFile.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\n\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  const valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown input type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart,\n      addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart,\n      bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'input'\n    }\n  }\n\n  return { name: mapping.name, type, mapping, error: 'variable name does not match input mapping' }\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown output type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart,\n      addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart,\n      bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'output'\n    }\n  }\n\n  return { name: mapping.name, type, mapping, error: 'variable name does not match output mapping' }\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    const item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  const registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    if (logging) {\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n      ioCore.internalDebug(JSON.stringify(item))\n    }\n    return item\n  }\n\n  if (logging) {\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n  }\n\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  const sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'dataType') || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\n      } catch (err) {\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      if (logging) {\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\n      }\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\n  if (!valueNames.length || !valueNames.filter) {\n    return valueNames\n  }\n\n  const ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  const startRegister = adr\n  const endRegister = Number(adr) + Number(quantity) - 1\n\n  if (node.logIOActivities) {\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n  }\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  const sizeDivisor = Number(bits) || 16\n  const startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\n  const origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\n  origMsg.modbusRequest = Object.assign({}, msg.payload)\n  origMsg.payload = values\n  origMsg.topic = msg.topic\n  origMsg.responseBuffer = response\n\n  const rawMsg = Object.assign({}, origMsg)\n  rawMsg.payload = response\n  rawMsg.values = values\n  delete rawMsg.responseBuffer\n\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n    const allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\n    const valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\n      parseInt(msg.payload.address) || 0,\n      parseInt(msg.payload.quantity) || 1,\n      node.logIOActivities)\n\n    if (node.useIOForPayload) {\n      origMsg.payload = valueNames\n      origMsg.values = values\n    } else {\n      origMsg.payload = values\n      origMsg.valueNames = valueNames\n    }\n\n    rawMsg.valueNames = valueNames\n    return [origMsg, rawMsg]\n  } else {\n    return [origMsg, rawMsg]\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}