{"version":3,"sources":["core/modbus-queue-core.js"],"names":["require","install","de","biancoroyal","modbus","queue","core","internalDebug","initQueue","node","bufferCommandList","clear","sendingAllowed","unitSendingAllowed","step","set","queuesAreEmpty","get","length","queueSerialUnlockCommand","this","name","id","serialSendingAllowed","queueSerialLockCommand","sequentialDequeueCommand","Promise","resolve","parallelUnitIdsAllowed","unitId","shift","queueCore","isValidUnitId","Error","queueLog","JSON","stringify","sendQueueDataToModbus","reject","warn","infoText","queueLength","type","command","callModbus","msg","cb","cberr","dequeueLogEntry","state","info","actualServiceState","then","err","message","commandDelay","parseInt","payload","unitid","unit_id","dequeueCommand","messageAllowedStates","indexOf","pushToQueueByUnitId","coreQueue","getUnitIdToQueue","getQueueLengthByUnitId","clienttype","push","module","exports"],"mappings":"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","file":"../../core/modbus-queue-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { queue: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.internalDebug = de.biancoroyal.modbus.queue.core.internalDebug || require('debug')('contribModbus:queue:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.core = de.biancoroyal.modbus.queue.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.queue.core.initQueue = function (node) {\n  node.bufferCommandList.clear()\n  node.sendingAllowed.clear()\n  node.unitSendingAllowed = []\n\n  for (let step = 0; step <= 255; step++) {\n    node.bufferCommandList.set(step, [])\n    node.sendingAllowed.set(step, true)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.checkQueuesAreEmpty = function (node) {\n  let queuesAreEmpty = true\n  for (let step = 0; step <= 255; step++) {\n    queuesAreEmpty &= (node.bufferCommandList.get(step).length === 0)\n  }\n  return queuesAreEmpty\n}\n\nde.biancoroyal.modbus.queue.core.queueSerialUnlockCommand = function (node) {\n  this.internalDebug('queue serial unlock command node name: ' + node.name + ' id: ' + node.id)\n  node.serialSendingAllowed = true\n}\n\nde.biancoroyal.modbus.queue.core.queueSerialLockCommand = function (node) {\n  this.internalDebug('queue serial lock command node name: ' + node.name + ' id: ' + node.id)\n  node.serialSendingAllowed = false\n}\n\nde.biancoroyal.modbus.queue.core.sequentialDequeueCommand = function (node) {\n  this.internalDebug('sequential de-queue command')\n  return new Promise(\n    function (resolve, reject) {\n      const queueCore = de.biancoroyal.modbus.queue.core\n\n      if (node.parallelUnitIdsAllowed) {\n        for (let unitId = 0; unitId < 256; unitId += 1) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        }\n      } else {\n        const unitId = node.unitSendingAllowed.shift()\n        if (!queueCore.isValidUnitId(unitId)) {\n          reject(new Error('UnitId ' + unitId + ' is not valid from dequeue of sending list'))\n          return\n        }\n\n        node.queueLog(JSON.stringify({\n          type: 'sequential dequeue command',\n          unitId,\n          isValidUnitId: queueCore.isValidUnitId(unitId),\n          sendingAllowed: node.sendingAllowed.get(unitId),\n          serialSendingAllowed: node.serialSendingAllowed\n        }))\n\n        if (queueCore.isValidUnitId(unitId) &&\n          node.sendingAllowed.get(unitId)) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        } else {\n          node.warn('sequential dequeue command not possible for Unit ' + unitId)\n          let infoText = 'sending is allowed for Unit '\n          if (node.sendingAllowed.get(unitId)) {\n            node.warn(infoText + unitId)\n          } else {\n            node.warn('no ' + infoText + unitId)\n          }\n          infoText = 'valid Unit '\n          if (queueCore.isValidUnitId(unitId)) {\n            node.warn(infoText + unitId)\n          } else {\n            node.warn('no ' + infoText + unitId)\n          }\n          infoText = ' serial sending allowed for Unit '\n          if (node.serialSendingAllowed) {\n            node.warn(node.name + infoText + unitId)\n          } else {\n            node.warn(node.name + ' no' + infoText + unitId)\n          }\n        }\n      }\n      resolve()\n    })\n}\n\nde.biancoroyal.modbus.queue.core.sendQueueDataToModbus = function (node, unitId) {\n  const queueLength = node.bufferCommandList.get(unitId).length\n  node.queueLog(JSON.stringify({\n    type: 'send queue data to Modbus',\n    unitId,\n    queueLength,\n    sendingAllowed: node.sendingAllowed.get(unitId),\n    serialSendingAllowed: node.serialSendingAllowed\n  }))\n\n  if (queueLength) {\n    const command = node.bufferCommandList.get(unitId).shift()\n    if (command) {\n      node.sendingAllowed.set(unitId, false)\n      command.callModbus(node, command.msg, command.cb, command.cberr)\n    } else {\n      throw new Error('Command On Send Not Valid')\n    }\n  }\n}\n\nde.biancoroyal.modbus.queue.core.dequeueLogEntry = function (node, state, info) {\n  node.queueLog(JSON.stringify({\n    state: state.value,\n    message: `${info} ${node.clienttype}`,\n    delay: node.commandDelay\n  }))\n}\n\nde.biancoroyal.modbus.queue.core.dequeueCommand = function (node) {\n  const queueCore = de.biancoroyal.modbus.queue.core\n  const state = node.actualServiceState\n\n  if (node.messageAllowedStates.indexOf(state.value) === -1) {\n    queueCore.dequeueLogEntry(node, state, 'dequeue command disallowed state')\n  } else {\n    queueCore.sequentialDequeueCommand(node).then(function () {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command done')\n    }).catch(function (err) {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command error ' + err.message)\n    })\n  }\n}\n\nde.biancoroyal.modbus.queue.core.getUnitIdToQueue = function (node, msg) {\n  return parseInt(msg.payload.unitid) || parseInt(node.unit_id) || 0\n}\n\nde.biancoroyal.modbus.queue.core.isValidUnitId = function (unitId) {\n  return (unitId >= 0 && unitId <= 255)\n}\n\nde.biancoroyal.modbus.queue.core.getQueueLengthByUnitId = function (node, unitId) {\n  if (this.isValidUnitId(unitId)) {\n    return node.bufferCommandList.get(unitId).length\n  } else {\n    throw new Error('(0-255) Got A Wrong Unit-Id: ' + unitId)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.pushToQueueByUnitId = function (node, callModbus, msg, cb, cberr) {\n  const coreQueue = de.biancoroyal.modbus.queue.core\n\n  return new Promise(\n    function (resolve, reject) {\n      try {\n        const unitId = coreQueue.getUnitIdToQueue(node, msg)\n        if (!coreQueue.isValidUnitId(unitId)) {\n          reject(new Error('UnitId ' + unitId + ' is not valid from msg or node'))\n          return\n        } else {\n          node.queueLog(JSON.stringify({\n            info: 'will push to Queue by Unit-Id',\n            message: msg.payload,\n            unitId\n          }))\n        }\n        const queueLength = coreQueue.getQueueLengthByUnitId(node, unitId)\n\n        msg.queueLengthByUnitId = { unitId, queueLength }\n        msg.queueUnitId = unitId\n\n        if (!node.parallelUnitIdsAllowed || node.clienttype === 'serial') {\n          node.unitSendingAllowed.push(unitId)\n        }\n\n        node.bufferCommandList.get(unitId).push({ callModbus, msg, cb, cberr })\n        node.queueLog(JSON.stringify({\n          info: 'pushed to Queue by Unit-Id',\n          message: msg.payload,\n          unitId\n        }))\n        resolve()\n      } catch (err) {\n        reject(err)\n      }\n    })\n}\n\nmodule.exports = de.biancoroyal.modbus.queue.core\n"]}