{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","createNode","this","name","internalDebugLog","showStatusActivities","showErrors","unitid","dataType","adr","keepMsgProperties","quantity","emptyMsgOnFail","modbusClient","node","verboseLogging","settings","bufferMessageList","getNode","server","registerForModbus","initModbusClientEvents","onModbusWriteDone","msg","send","buildMessage","payload","resp","emit","errorProtocolMsg","err","onModbusWriteError","message","getOriginalMessage","origMsg","sendEmptyMsgOnFail","setMsgPayloadFromHTTPRequests","call","value","hasOwnProperty","Object","prototype","indexOf","buildNewMessageObject","messageId","getObjectId","topic","fc","functionCodeModbusWrite","address","on","origMsgInput","assign","client","httpMsg","newMsg","setNodeStatusTo","actualServiceState","done","id"],"mappings":"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","file":"../modbus-write.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Write node.\n * @module NodeRedModbusWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const internalDebugLog = require('debug')('contribModbus:write')\n\n  function ModbusWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.unitid = config.unitid\n    this.dataType = config.dataType\n    this.adr = Number(config.adr)\n    this.quantity = config.quantity\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('write done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n      node.emit('modbusWriteNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusWriteNodeError')\n    }\n\n    node.setMsgPayloadFromHTTPRequests = function (msg) {\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') &&\n        typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n      return msg\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: (Object.prototype.hasOwnProperty.call(msg.payload, 'value')) ? msg.payload.value : msg.payload,\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusWrite(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId\n        }\n      }\n    }\n\n    node.on('input', function (msg) {\n      const origMsgInput = Object.assign({}, msg)\n\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      try {\n        const httpMsg = node.setMsgPayloadFromHTTPRequests(origMsgInput)\n        const newMsg = node.buildNewMessageObject(node, httpMsg)\n        node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, httpMsg, newMsg))\n        modbusClient.emit('writeModbus', newMsg, node.onModbusWriteDone, node.onModbusWriteError)\n\n        if (node.showStatusActivities) {\n          mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-write', ModbusWrite)\n}\n"]}