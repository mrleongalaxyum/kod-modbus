{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","install","modbus","require","net","mbBasics","nodes","registerType","config","createNode","this","name","internalDebugLog","hostname","serverPort","ModbusServer","parseInt","responseDelay","bufferFactor","delayUnit","logEnabled","coilsBufferSize","holdingBufferSize","inputBufferSize","showErrors","modbusLogLevel","node","verboseLogging","modbusServer","settings","verbose","netServer","Server","server","TCP","logLabel","logLevel","alloc","calc_rateByUnit","coils","Buffer","holding","input","on","client","socket","JSON","stringify","address","remoteAddress","remotePort","setNodeStatusTo","listen","showStatusActivities","err","message","warn","msg","disableMsgOutput","type","payload","discrete","buildMessage","coreServer","isValidMemoryMessage","send","close","done"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const modbus = require('jsmodbus')\n  const net = require('net')\n  const coreServer = require('./core/modbus-server-core')\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n\n    const bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay) || 1\n    this.delayUnit = config.delayUnit\n\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        logLabel: 'ModbusServer',\n        logLevel: modbusLogLevel,\n        logEnabled: node.logEnabled,\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\n        input: Buffer.alloc(node.inputBufferSize, 0),\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n\n      if (!node.showStatusActivities) {\n        mbBasics.setNodeDefaultStatus(node)\n      }\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.netServer.on('error', function (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    })\n\n    node.on('input', function (msg) {\n      if (coreServer.isValidMemoryMessage(msg)) {\n        coreServer.writeToServerMemory(node, msg)\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      } else {\n        if (node.showErrors) {\n          node.error('Is Not A Valid Memory Write Message To Server', msg)\n        }\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      }\n    })\n\n    function buildMessage (msg) {\n      return [\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\n        { type: 'input', message: msg, payload: node.modbusServer.input },\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete },\n        { payload: 'request', type: 'message', message: msg }\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n        })\n      }\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    internalDebugLog(err.message)\n  }\n}\n"]}