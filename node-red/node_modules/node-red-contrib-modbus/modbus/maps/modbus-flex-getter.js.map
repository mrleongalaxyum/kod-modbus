{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","internalDebugLog","nodes","registerType","config","createNode","this","mbIOCore","showStatusActivities","connection","useIOFile","name","getNode","ioFile","showErrors","useIOForPayload","logIOActivities","keepMsgProperties","bufferMessageList","node","verboseLogging","verbose","Map","server","modbusClient","initModbusClientEvents","onModbusReadDone","resp","msg","data","buildMessageWithIO","logMsgError","err","message","origMsg","getOriginalMessage","errorProtocolMsg","onModbusReadError","setModbusError","payload","JSON","parse","fc","unitid","address","parseInt","quantity","isValidModbusMsg","isValid","Number","isInteger","error","value","topic","id","messageId","emptyMsgOnFail","on","origMsgInput","invalidPayloadIn","client","inputMsg","newMsg","buildNewMessageObject","set","buildNewMessage","setNodeStatusTo","done","actualServiceState","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusFlexGetterNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexGetterNodeError')\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg.payload === 'string') {\n        msg.payload = JSON.parse(msg.payload)\n      }\n\n      msg.payload.fc = parseInt(msg.payload.fc) || 3\n      msg.payload.unitid = parseInt(msg.payload.unitid)\n      msg.payload.address = parseInt(msg.payload.address) || 0\n      msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.payload.fc) &&\n              msg.payload.fc >= 1 &&\n              msg.payload.fc <= 4)) {\n        node.error('FC Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.address) &&\n            msg.payload.address >= 0 &&\n            msg.payload.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.quantity) &&\n            msg.payload.quantity >= 1 &&\n            msg.payload.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: msg.payload.value || msg.value,\n          unitid: msg.payload.unitid,\n          fc: msg.payload.fc,\n          address: msg.payload.address,\n          quantity: msg.payload.quantity,\n          emptyMsgOnFail: node.emptyMsgOnFail,\n          keepMsgProperties: node.keepMsgProperties,\n          messageId\n        }\n      }\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg) || !modbusClient.client) {\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg) // keep it origin\n      try {\n        const inputMsg = node.prepareMsg(origMsgInput)\n        if (node.isValidModbusMsg(inputMsg)) {\n          const newMsg = node.buildNewMessageObject(node, inputMsg)\n          node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\n          modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}